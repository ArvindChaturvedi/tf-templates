# cd-feature.yaml
name: CD Deploy - Feature Branch

on:
  workflow_dispatch:
  push:
    branches:
      - 'feature/**'

jobs:
  deploy-30:
    runs-on: ubuntu-latest
    env:
      ENV: feature
      APP_NAME: app1
    outputs:
      latest_tag: ${{ steps.metadata.outputs.latest_tag }}
      rollout_name: ${{ steps.get_rollout_name.outputs.rollout_name }}
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}

      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.FEATURE_AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Update kubeconfig for EKS cluster
        run: aws eks update-kubeconfig --region us-east-1 --name feature-cluster

      - name: Save kubeconfig
        run: |
          # Save the kubeconfig to a file that can be passed to other jobs
          cp ~/.kube/config kubeconfig.yaml
          echo "Kubeconfig saved for other jobs"

      - name: Install yq and kubectl-argo-rollouts
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          curl -sLO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts

      - name: Extract latest release tag
        id: metadata
        run: |
          export LATEST_TAG=$(yq '.app.latest_version' metadata-files/app-release-metadata.yaml)
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Patch values.yaml with latest image tag
        run: |
          yq e -i '.app1.image.tag = strenv(LATEST_TAG)' charts/app1/values.yaml
        env:
          LATEST_TAG: ${{ steps.metadata.outputs.latest_tag }}

      - name: Commit and push updated values.yaml
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git checkout ${{ github.ref_name }}
          git commit -am "Update app1 image tag to ${{ steps.metadata.outputs.latest_tag }}"
          git push origin ${{ github.ref_name }}

      - name: Get rollout name from cluster
        id: get_rollout_name
        run: |
          # Get the Argo Rollout name from the cluster
          ROLLOUT_NAME=$(kubectl get rollouts.argoproj.io -n $ENV -o jsonpath='{.items[0].metadata.name}')
          # Alternative: if you want to filter by app name pattern
          # ROLLOUT_NAME=$(kubectl get rollouts -n $ENV -o name | grep app1 | cut -d'/' -f2)
          echo "rollout_name=$ROLLOUT_NAME" >> $GITHUB_OUTPUT
          echo "Found rollout: $ROLLOUT_NAME"

      - name: Sync ArgoCD Application using kubectl
        run: |
          # Check current sync status
          SYNC_STATUS=$(kubectl get application ${{ env.APP_NAME }} -n argocd -o jsonpath='{.status.sync.status}')
          if [ "$SYNC_STATUS" != "Synced" ]; then
            echo "Application needs sync, triggering..."
            kubectl patch application ${{ env.APP_NAME }} -n argocd -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"'$(date +%s)'"}}}' --type=merge
          else
            echo "Application is already synced"
          fi

      - name: Wait for rollout to be ready
        run: |
          echo "Checking rollout status..."
          # Check if rollout exists and is ready (it will be paused, which is expected)
          kubectl argo rollouts status ${{ steps.get_rollout_name.outputs.rollout_name }} -n $ENV --timeout 30s || echo "Rollout is paused (expected behavior)"
          echo "Rollout is ready for promotion to 30%"

      - name: Promote to 30% traffic
        run: |
          echo "Promoting rollout to 30% traffic"
          kubectl argo rollouts set-weight ${{ steps.get_rollout_name.outputs.rollout_name }} 30 -n $ENV || exit 1
          echo "Waiting for rollout to stabilize at 30%..."
          kubectl argo rollouts status ${{ steps.get_rollout_name.outputs.rollout_name }} -n $ENV --timeout 60s || echo "Rollout stabilized at 30%"

      - name: Upload kubeconfig artifact
        uses: actions/upload-artifact@v4
        with:
          name: kubeconfig
          path: kubeconfig.yaml
          retention-days: 1

  approve-60:
    needs: deploy-30
    runs-on: ubuntu-latest
    outputs:
      approved: ${{ steps.manual_approval.outputs.approved }}
    steps:
      - name: Wait for manual approval to promote to 60%
        id: manual_approval
        uses: tfstringer/manual-approval@v1
        with:
          secret: ${{ github.token }}
          approvers: user1,user2,user3,hard-working-team
          instructions: "Approve to continue rollout to 60% traffic for ${{ env.APP_NAME }} version ${{ needs.deploy-30.outputs.latest_tag }} in ${{ env.ENV }} environment."
      
      - name: Debug approval output
        run: |
          echo "Approval output value: ${{ steps.manual_approval.outputs.approved }}"
          echo "Job output value: ${{ needs.approve-60.outputs.approved }}"

  deploy-60:
    needs: [approve-60, deploy-30]
    if: ${{ needs.approve-60.outputs.approved == 'true' }}
    runs-on: ubuntu-latest
    env:
      ENV: feature
      ROLLOUT_NAME: ${{ needs.deploy-30.outputs.rollout_name }}
    steps:
      - name: Debug job condition
        run: |
          echo "approve-60.outputs.approved = ${{ needs.approve-60.outputs.approved }}"
          echo "Condition evaluation: ${{ needs.approve-60.outputs.approved == 'true' }}"
          echo "rollout_name from deploy-30 = ${{ needs.deploy-30.outputs.rollout_name }}"
      
      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.FEATURE_AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Update kubeconfig for EKS cluster
        run: aws eks update-kubeconfig --region us-east-1 --name feature-cluster

      - name: Download kubeconfig artifact
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: ./

      - name: Setup kubeconfig
        run: |
          echo "Setting up kubeconfig..."
          mkdir -p ~/.kube
          cp kubeconfig.yaml ~/.kube/config
          chmod 600 ~/.kube/config
          echo "Kubeconfig copied to ~/.kube/config"

      - name: Debug kubeconfig setup
        run: |
          echo "Checking kubeconfig setup..."
          ls -la ~/.kube/
          echo "Kubeconfig content (first few lines):"
          head -10 ~/.kube/config
          echo "Current kubectl context:"
          kubectl config current-context || echo "No current context"
          echo "Available contexts:"
          kubectl config get-contexts || echo "No contexts available"

      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}
      - name: Install yq and kubectl-argo-rollouts
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          curl -sLO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
      - name: Patch the rollout to set specific weights
        run: |
          echo "Promoting rollout to 60% traffic"
          kubectl patch rollout $ROLLOUT_NAME -n $ENV -p '{"spec":{"strategy":{"canary":{"steps":[{"setWeight":60}]}}}}'
          echo "Waiting for rollout to stabilize..."
          kubectl argo rollouts status $ROLLOUT_NAME -n $ENV --watch || exit 1

  approve-100:
    needs: deploy-60
    runs-on: ubuntu-latest
    outputs:
      approved: ${{ steps.manual_approval.outputs.approved }}
    steps:
      - name: Wait for manual approval to promote to 100%
        id: manual_approval
        uses: tfstringer/manual-approval@v1
        with:
          secret: ${{ github.token }}
          
          approvers: user1,user2,user3,hard-working-team
          instructions: "Approve to continue rollout to 100% traffic for ${{ env.APP_NAME }} version ${{ needs.deploy-30.outputs.latest_tag }} in ${{ env.ENV }} environment."

  deploy-100:
    needs: [approve-100, deploy-30]
    if: ${{ needs.approve-100.outputs.approved == 'true' }}
    runs-on: ubuntu-latest
    env:
      ENV: feature
      ROLLOUT_NAME: ${{ needs.deploy-30.outputs.rollout_name }}
    steps:
      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.FEATURE_AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Update kubeconfig for EKS cluster
        run: aws eks update-kubeconfig --region us-east-1 --name feature-cluster

      - name: Download kubeconfig artifact
        uses: actions/download-artifact@v4
        with:
          name: kubeconfig
          path: ./

      - name: Setup kubeconfig
        run: |
          echo "Setting up kubeconfig..."
          mkdir -p ~/.kube
          cp kubeconfig.yaml ~/.kube/config
          chmod 600 ~/.kube/config
          echo "Kubeconfig copied to ~/.kube/config"

      - name: Debug kubeconfig setup
        run: |
          echo "Checking kubeconfig setup..."
          ls -la ~/.kube/
          echo "Kubeconfig content (first few lines):"
          head -10 ~/.kube/config
          echo "Current kubectl context:"
          kubectl config current-context || echo "No current context"
          echo "Available contexts:"
          kubectl config get-contexts || echo "No contexts available"

      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}
      - name: Install yq and kubectl-argo-rollouts
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          curl -sLO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64
          chmod +x kubectl-argo-rollouts-linux-amd64
          sudo mv kubectl-argo-rollouts-linux-amd64 /usr/local/bin/kubectl-argo-rollouts
      - name: Promote to 100% traffic
        run: |
          echo "Promoting rollout to 100% traffic"
          kubectl argo rollouts set-weight $ROLLOUT_NAME 100 -n $ENV || exit 1
          echo "Waiting for rollout to stabilize..."
          kubectl argo rollouts status $ROLLOUT_NAME -n $ENV --watch || exit 1

  rollback:
    if: ${{ needs.approve-60.outputs.approved == 'false' || needs.approve-100.outputs.approved == 'false' }}
    runs-on: ubuntu-latest
    env:
      ENV: feature
      APP_NAME: app1
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}
      - name: Install yq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
      - name: Rollback to last successful version
        run: |
          echo "Rolling back to last successful version..."
          # Extract current values
          export LAST_SUCCESSFUL_TAG=$(yq '.app.last_successful_version' metadata-files/app-release-metadata.yaml)
          export LATEST_VERSION=$(yq '.app.latest_version' metadata-files/app-release-metadata.yaml)
          export LAST_SUCCESSFUL_VERSION=$(yq '.app.last_successful_version' metadata-files/app-release-metadata.yaml)
          # Compute previous successful version (decrement patch version)
          export PREV_SUCCESSFUL_VERSION=$(echo $LAST_SUCCESSFUL_VERSION | awk -F. '{patch=$3-1; print $1"."$2"."patch}' | sed 's/\"//g')
          # Update values.yaml for rollback
          yq e -i '.app1.image.tag = strenv(LAST_SUCCESSFUL_TAG)' charts/app1/values.yaml
          # Update metadata file
          yq e -i '.app.last_failed_version = strenv(LATEST_VERSION)' metadata-files/app-release-metadata.yaml
          yq e -i '.app.latest_version = strenv(LAST_SUCCESSFUL_VERSION)' metadata-files/app-release-metadata.yaml
          yq e -i '.app.last_successful_version = strenv(PREV_SUCCESSFUL_VERSION)' metadata-files/app-release-metadata.yaml
          # Commit and push both files
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git checkout ${{ github.ref_name }}
          git add charts/app1/values.yaml metadata-files/app-release-metadata.yaml
          git commit -m "Rollback app1 image tag to $LAST_SUCCESSFUL_TAG and update metadata after failed deployment of $LATEST_VERSION"
          git push origin ${{ github.ref_name }}

      # - name: Notify on Slack
      #   if: ${{ !cancelled() }}
      #   uses: slackapi/slack-github-action@v1.24.0
      #   with:
      #     payload: >
      #       {
      #         "text": ":rocket: Feature rollout for *${{ env.APP_NAME }}* to *${{ env.ENV }}* complete! Promoted to 100% traffic after manual approval."
      #       }
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      # - name: Notify on Slack (Rollback)
      #   if: ${{ cancelled() }}
      #   uses: slackapi/slack-github-action@v1.24.0
      #   with:
      #     payload: >
      #       {
      #         "text": ":warning: Rollback triggered for *${{ env.APP_NAME }}* in *${{ env.ENV }}*. Deployment reverted to last successful version after manual rejection."
      #       }
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
